"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../../library/core/utils/theme/theme.ts
  var _Theme = class _Theme {
    constructor() {
      /**
       * The colors
       */
      this.colors = {
        selection: "#FF601C",
        primary: "#FF601C",
        secondary: "#0B75F2",
        light: "#FFFFFF",
        dark: "#333333",
        trace: "#1CFFA3",
        info: "#3DB9FE",
        debug: "#E7FF48",
        verbose: "#FF601C",
        warn: "#FED424",
        error: "#FF3F66",
        success: "#4BFE55"
      };
    }
  };
  __name(_Theme, "Theme");
  /**
   * The current theme
   */
  _Theme.current = new _Theme();
  var Theme = _Theme;

  // ../../library/core/utils/logger/logger.base.ts
  var _Logger = class _Logger {
    constructor() {
      /**
       * The amount of indents per level
       */
      this.indentsPerLevel = 4;
    }
    /**
     * Prints a message for the clients to see, except if the type
     * provided is verbose, debug or trace.
     * @param options the options
     * @param data any data
     */
    label(type, label, ...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[${label.substring(0, 1).toUpperCase()}${label.substring(1)}] ${d}` : d, "convert");
      this.perform({ type }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a warning message for the clients to see
     * @param data any data
     */
    success(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Success] ${d} ` : d, "convert");
      this.perform({ type: "success" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a warning message for the clients to see
     * @param data any data
     */
    warn(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Warn] ${d} ` : d, "convert");
      this.perform({ type: "warn" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints an error message for the clients to see
     * @param data any data
     */
    error(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Error] ${d}` : d, "convert");
      this.perform({ type: "error" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a message for the clients to see
     * @param data any data
     */
    info(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Info] ${d} ` : d, "convert");
      this.perform({ type: "info" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a message when the --verbose, --debug or --trace flag is present,
     * this is the lowest level of debug information.
     * @param data any data
     */
    trace(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Trace] ${d} ` : d, "convert");
      this.perform({ type: "trace" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a message when the --verbose or --debug flag is present,
     * this is the default level of debug information.
     * @param data any data
     */
    debug(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Debug] ${d} ` : d, "convert");
      this.perform({ type: "debug" }, ...data.map((v) => convert(v)));
    }
    /**
     * Prints a message when the --verbose flag is present,
     * this is the highest level of debug information.
     * @param data any data
     */
    verbose(...data) {
      const convert = /* @__PURE__ */ __name((d) => ["string", "number", "boolean", "bigint"].includes(typeof d) ? `[Verbose] ${d} ` : d, "convert");
      this.perform({ type: "verbose" }, ...data.map((v) => convert(v)));
    }
    /**
     * Performs printing the log message
     * @param options options
     * @param data the data
     * @returns 
     */
    perform(options, ...data) {
      let {
        type
      } = options;
      const flags = {
        verbose: ["--verbose"],
        debug: ["--verbose", "--debug"],
        trace: ["--verbose", "--debug", "--trace"],
        info: [],
        warn: [],
        error: [],
        success: []
      }[type];
      if (flags.length && !this.argv.find((v) => flags.includes(v))) {
        return;
      }
      for (const d of data) {
        if (typeof d === "string" || typeof d === "boolean" || typeof d === "number" || typeof d === "bigint" || typeof d === "function" || typeof d === "symbol" || typeof d === "undefined") {
          console.log(`${d} `);
        } else {
          console.log(d);
        }
      }
    }
  };
  __name(_Logger, "Logger");
  var Logger = _Logger;

  // ../../library/core/utils/logger/logger.esm.ts
  var _Logger2 = class _Logger2 extends Logger {
    /**
     * Get the current theme colors
     */
    get colors() {
      return Theme.current.colors;
    }
    /**
     * The process.argv arguments used for this logger
     */
    get argv() {
      return window.location.search.split(/\?|\&/).filter(Boolean).map((v) => `--${v}`);
    }
  };
  __name(_Logger2, "Logger");
  var Logger2 = _Logger2;

  // ../../library/core/utils/reactive/listener.ts
  var _Listener = class _Listener {
    /**
     * Creates a new listener instance.
     * @param {Emitter<Event>} event - The event this listener is attached to.
     * @param {function(arg: Event): void} fire - The callback function to execute when the listener is triggered.
     */
    constructor(event, fire) {
      this.event = event;
      this.fire = fire;
    }
    /**
     * Unsubscribe the listener from the event.
     */
    unsubscribe() {
      this.event.unsubscribe(this);
    }
  };
  __name(_Listener, "Listener");
  var Listener = _Listener;

  // ../../library/core/utils/reactive/emitter.ts
  var _Emitter = class _Emitter {
    constructor() {
      this.listeners = {
        once: [],
        always: []
      };
      /**
       * Listen methods for adding event listeners.
       */
      this.listen = {
        /**
         * Add an event listener that triggers on every event emission.
         * @param {function(arg: Event): void} callback - The callback function to execute on event emission.
         * @returns {Listener<Event>} The listener instance.
         */
        always: (callback) => {
          const listener = new Listener(this, callback);
          this.listeners.always.push(listener);
          return listener;
        },
        /**
         * Add an event listener that triggers only once.
         * @param {function(arg: Event): void} callback - The callback function to execute on event emission.
         * @returns {Listener<Event>} The listener instance.
         */
        once: (callback) => {
          const listener = new Listener(this, callback);
          this.listeners.once.push(listener);
          return listener;
        }
      };
    }
    /**
     * Emit the event, triggering all attached listeners.
     * @param {Event} arg - The argument to pass to the listeners.
     */
    emit(arg) {
      return __async(this, null, function* () {
        const promises = [];
        for (const listener of this.listeners.once) {
          const promise = listener.fire(arg);
          if (promise instanceof Promise) {
            promises.push(promise);
          }
          this.unsubscribe(listener);
        }
        for (const listener of this.listeners.always) {
          const promise = listener.fire(arg);
          if (promise instanceof Promise) {
            promises.push(promise);
          }
        }
        yield Promise.all(promises);
      });
    }
    /**
     * Unsubscribe a listener from the event.
     * @param {Listener<Event>} listener - The listener to unsubscribe.
     */
    unsubscribe(listener) {
      this.listeners.always = this.listeners.always.filter((l) => l !== listener);
      this.listeners.once = this.listeners.once.filter((l) => l !== listener);
    }
  };
  __name(_Emitter, "Emitter");
  var Emitter = _Emitter;

  // ../../library/framework/apps/frontend/components/component/component.ts
  var _Component = class _Component {
    constructor(props) {
      /**
       * The logger
       */
      this.logger = new Logger2();
      /**
       * The component
       */
      this.component = this;
      /**
       * The component's event emitters, when extending this with your own emitters
       * use the spread syntax ...super.emitters in your object so they keep existing.
       */
      this.emitters = {
        initialization: new Emitter(),
        mounted: new Emitter(),
        // TODO: 
        propsChanged: new Emitter(),
        // TODO: 
        beforeRender: new Emitter(),
        // TODO:
        afterRender: new Emitter(),
        // TODO:
        umounted: new Emitter()
      };
      /**
       * Here you can add your event listeners of `this.emitters`; they will be automatically
       * unsubscribed after the component unmounts. No worries about the cleanup there.
       */
      this.listeners = [];
      /**
       * Event listeners that are there for every component
       */
      this._listeners = [
        this.component.emitters.umounted.listen.once(() => {
          [...this.component._listeners, ...this.component.listeners].forEach((l) => l.unsubscribe());
        })
      ];
      /**
       * Whether or not the state has been initialized
       */
      this._stateInitialized = false;
      /**
       * The internal state of the component
       */
      this._state = {};
      if (!props.children) {
        throw new Error(`Component props.children is not present`);
      }
      this.props = props;
      this.emitters.initialization.emit({
        component: this
      });
      this.emitters.propsChanged.emit({
        component: this,
        props: this.props
      });
    }
    /**
     * Get/set the associated VNode of this component
     */
    get vnode() {
      return this.component._vnode;
    }
    set vnode(vnode) {
      this.component._vnode = vnode;
    }
    /**
     * Get or sets the state, if set a deep Proxy is created to
     * automatically call this.rerender() upon any changes anywhere
     * within the state object with infinite depth.
     */
    get state() {
      return this.component._state;
    }
    set state(state) {
      const deepProxy = /* @__PURE__ */ __name((target, path) => new Proxy(target, {
        get: (obj, prop) => {
          this.component.logger.verbose("get", path);
          const value = obj[prop];
          if (typeof value === "object" && value !== null) {
            const newPath = [...path, String(prop)];
            return deepProxy(value, newPath);
          }
          return value;
        },
        /**
         * Intercept property assignment
         */
        set: (obj, prop, newValue) => {
          if (obj[prop] === newValue) {
            this.component.logger.verbose(`set called without any changes`, path);
            return true;
          }
          this.component.logger.verbose("set", path);
          obj[prop] = newValue;
          this.component.rerender();
          return true;
        }
      }), "deepProxy");
      this.component._state = deepProxy(state, []);
      if (!this.component._stateInitialized) {
        this.component._stateInitialized = true;
      } else {
        this.component.rerender();
      }
    }
    /**
     * Gets or sets the child nodes
     */
    get children() {
      return this.component.props.children || [];
    }
    set children(value) {
      this.component.props.children = value;
    }
    /**
     * Rerenders the entire component in the VDOM, then applies it to the changes to the DOM right after.
     */
    rerender() {
      var _a, _b;
      const vnode = this.vnode;
      if (!vnode.rootElement) {
        this.logger.verbose({ vnode });
        throw new Error(`VNode has no root element.`);
      }
      if (vnode.element && !((_a = vnode.parent) == null ? void 0 : _a.rootElement)) {
        this.logger.verbose({ vnode });
        throw new Error(`VNode has element but no parent with root element.`);
      }
      if (vnode.component) {
        if (!vnode.renderNode) {
          return;
        }
        const indices = vnode.getRootElementIndices();
        const min = indices[0];
        const max = indices[indices.length - 1];
        console.log({
          indices,
          min,
          max,
          root: vnode.rootElement,
          el: vnode.element,
          vnode
        });
        const element = vnode.rootElement;
        for (let i = max; i >= min; i--) {
          element.removeChild(element.childNodes[i]);
        }
        vnode.renderNode = (_b = vnode.component) == null ? void 0 : _b.render();
        if (vnode.renderNode) {
          vnode.renderNode.renderNodeParent = vnode;
          vnode.renderNode.createElements();
          const getElements = /* @__PURE__ */ __name((vnode2, elements2 = []) => {
            if (vnode2.component) {
              if (vnode2.renderNode) {
                getElements(vnode2.renderNode, elements2);
              } else if (vnode2.renderNode === void 0) {
                this.logger.verbose({ vnode: vnode2 });
                throw new Error(`VNode has a component, but no renderNode. Try calling \`this.createElements\` first.`);
              }
            } else if (vnode2.isFragment) {
              for (const child of vnode2.children) {
                getElements(child, elements2);
              }
            } else if (vnode2.element) {
              elements2.push(vnode2.element);
              if (!(vnode2.element instanceof Text)) {
                const fillElement = /* @__PURE__ */ __name((element2, vnode3) => {
                  if (vnode3.component) {
                    if (vnode3.renderNode) {
                      fillElement(element2, vnode3.renderNode);
                    } else if (vnode3.renderNode === void 0) {
                      this.logger.verbose({ vnode: vnode3 });
                      throw new Error(`VNode of type component is not rendered`);
                    }
                  } else if (vnode3.isFragment) {
                    for (const child of vnode3.children) {
                      fillElement(element2, child);
                    }
                  } else if (vnode3.element) {
                    if (vnode3.element instanceof Text) {
                      element2.append(vnode3.element);
                    } else {
                      element2.append(vnode3.element);
                      for (const child of vnode3.children) {
                        fillElement(vnode3.element, child);
                      }
                    }
                  }
                }, "fillElement");
                for (const child of vnode2.children) {
                  fillElement(vnode2.element, child);
                }
              }
              this.logger.verbose({ el: vnode2.element, children: vnode2.children });
            } else {
              this.logger.verbose({ vnode: vnode2 });
              throw new Error(`Invalid VNode.`);
            }
            return elements2;
          }, "getElements");
          const elements = getElements(vnode.renderNode);
          for (let i = min; i < elements.length + min; i++) {
            element.insertBefore(elements[i - min], element.childNodes[i]);
          }
        }
      } else {
        this.logger.verbose({ vnode });
        throw new Error(`The rerenderComponent function is only for components.`);
      }
    }
  };
  __name(_Component, "Component");
  var Component = _Component;

  // ../../library/core/utils/json.ts
  var _JSON = class _JSON {
    // TODO: upgrade that circular works properly,
    // if a node has a .parent, dont remove the .children from the node
    /**
     * The replacer for the JSON.stringify function
     */
    static get replacer() {
      const seen = /* @__PURE__ */ new WeakSet();
      return (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return "circular";
          }
          seen.add(value);
        }
        if (typeof value === "function") {
          if (value.prototype && value.prototype.constructor === value) {
            return `[class ${value.name}]`;
          } else {
            return `[function ${value.name}]`;
          }
        }
        return value;
      };
    }
    /**
     * Deserializes a json string into any object
     * @template T the type of object that is returned
     */
    static get deserialize() {
      return typeof window === "undefined" ? global.JSON.parse : window.JSON.parse;
    }
    /**
     * Serializes any object into a json string
     */
    static get serialize() {
      function serialize(obj, indents, replacer) {
        if (typeof window === "undefined") {
          return global.JSON.stringify(obj, replacer || _JSON.replacer, indents || 4);
        } else {
          return window.JSON.stringify(obj, replacer || _JSON.replacer, indents || 4);
        }
      }
      __name(serialize, "serialize");
      return serialize;
    }
  };
  __name(_JSON, "JSON");
  var JSON = _JSON;

  // ../../library/framework/apps/frontend/socket/socket-client.ts
  var _SocketClient = class _SocketClient {
    /**
     * Initialize the socket client
     */
    static initialize() {
      if (!VDOM.window.socket) {
        this.socket = new WebSocket("ws://localhost:3000");
        this.socket.addEventListener("open", (event) => {
          console.log("Connected to web socket");
        });
        this.socket.addEventListener("message", (event) => {
          var _a;
          if (event.data === "reload-script") {
            (_a = document.querySelector('body >script[src^="bundle.min.js"]')) == null ? void 0 : _a.remove();
            const script = document.createElement("script");
            script.src = `bundle.min.js`;
            script.type = "text/javascript";
            script.defer = true;
            document.body.append(script);
          } else if (event.data === "reload-style") {
            for (let i = 0; i < VDOM.document.head.childNodes.length; i++) {
              const node = VDOM.document.head.childNodes.item(i);
              if (node.tagName === "link") {
                node.remove();
              }
            }
            const link = document.createElement("link");
            link.href = "bundle.min.css";
            link.rel = "stylesheet";
            link.type = "text/css";
            VDOM.document.head.appendChild(link);
          }
        });
        this.socket.addEventListener("close", (event) => {
          console.log("Disconnected from web socket");
        });
        VDOM.window.socket = this.socket;
      }
    }
    /**
     * Sends a node to the server
     * @param vnode the vnode
     */
    static sendNode(vnode) {
      if (!this.socket) {
        this.initialize();
      }
      this.socket.send(JSON.serialize(vnode));
    }
    /**
     * Sends a VDOM to the server
     * @param vdom the vdom
     */
    static sendDOM(vdom) {
      if (!this.socket) {
        this.initialize();
      }
      this.socket.send(JSON.serialize(vdom));
    }
  };
  __name(_SocketClient, "SocketClient");
  /**
   * The web socket instance
   */
  _SocketClient.socket = null;
  var SocketClient = _SocketClient;

  // ../../library/core/utils/objects.ts
  var _Objects = class _Objects {
    /**
     * Deeply assigns objectB by objectA
     * @param objectA the object to assign to
     * @param objectB the object to assign with
     */
    static deepAssign(objectA, objectB) {
      for (const key of Object.keys(objectB)) {
        if (typeof objectA[key] === "object") {
          if (typeof objectB[key] === "object") {
            objectA[key] = this.deepAssign(objectA[key], objectB[key]);
          } else {
            objectA[key] = objectB[key];
          }
        } else {
          objectA[key] = objectB[key];
        }
      }
      return objectA;
    }
  };
  __name(_Objects, "Objects");
  var Objects = _Objects;

  // ../../library/framework/apps/frontend/vdom/vnode.ts
  var _VNode = class _VNode {
    /**
     * Creates a new VNode instance.
     * @param options - The options for the VNode.
     */
    constructor(options) {
      this.options = options;
      /**
       * The VNode id
       */
      this.id = ++VDOM.counter;
      /**
       * Registered event listeners
       */
      this.eventListeners = {};
      /**
       * Filled when the node is a render node within this parent
       */
      this.renderNodeParent = null;
      /**
       * The associated VDOM
       */
      this._vdom = null;
      /**
       * Whether the VNode should be updated
       */
      this.shouldUpdate = false;
      /**
       * Sets the root element to a node and fixes broken root elements recursively
       * @param element the element to set as the root element
       */
      this.setRootElement = /* @__PURE__ */ __name((element) => {
        this.rootElement = element;
        if (this.element instanceof Element) {
          element = this.element;
        }
        for (const child of this.children) {
          child.setRootElement(element);
        }
        if (this.renderNode) {
          for (const child of this.renderNode.children) {
            child.setRootElement(element);
          }
        }
      }, "setRootElement");
      this.options.appendedNodes = options.appendedNodes || [];
      if (this.options.component) {
        this.options.component.emitters.initialization.emit({
          component: this.options.component
        });
      }
    }
    /**
     * Whether or not the vnode is destroyed
     */
    get destroyed() {
      return false;
    }
    get logger() {
      return new Logger2();
    }
    /**
     * Get or set the HTML tag name of the element.
     */
    get tag() {
      return this.options.tag;
    }
    set tag(tag) {
      this.options.tag = tag;
    }
    /**
     * Get or set the HTML Text element of the vnode.
     */
    get text() {
      return this.options.text;
    }
    set text(text) {
      this.options.text = text;
    }
    /**
     * Get or set the renderNode of the vnode.
     */
    get renderNode() {
      return this.options.renderNode;
    }
    set renderNode(renderNode) {
      this.options.renderNode = renderNode;
    }
    /**
     * Gets the root vnode
     */
    get root() {
      let parent = this.parent;
      while (parent) {
        if (parent.parent) {
          parent = parent.parent;
        } else {
          return parent;
        }
      }
      return null;
    }
    /**
     * Gets or sets the latest VODM instance
     */
    set vdom(vdom) {
      let parent = this;
      while (parent) {
        if (parent.renderNodeParent || parent.parent) {
          parent._vdom = null;
          parent = parent.renderNodeParent || parent.parent;
        } else {
          parent._vdom = vdom || parent._vdom;
          break;
        }
      }
    }
    get vdom() {
      const vdom = (VDOM.window.VDOMS || []).find((v) => {
        var _a;
        return v.main === ((_a = this.root) == null ? void 0 : _a.rootElement);
      });
      let lastVDOM = null;
      let parent = this;
      while (parent) {
        if (parent.renderNodeParent || parent.parent) {
          lastVDOM = parent._vdom || lastVDOM;
          parent = parent.renderNodeParent || parent.parent;
        } else {
          if (parent._vdom !== vdom && vdom) {
            parent._vdom = vdom;
            return vdom;
          }
          return parent._vdom || lastVDOM;
        }
      }
      return vdom || this._vdom;
    }
    /**
     * Get or set the parent VNode.
     */
    get parent() {
      return this.renderNodeParent || this.options.parent;
    }
    set parent(parent) {
      this.options.parent = parent;
      if (this.options.parent) {
        this.options.parent.rootElement = this.rootElement;
        this.options.rootElement = void 0;
      }
    }
    /**
     * Get or set whether this VNode represents a fragment.
     */
    get isFragment() {
      return this.options.isFragment;
    }
    set isFragment(isFragment) {
      this.options.isFragment = isFragment;
    }
    /**
     * Get or set the component associated with this VNode.
     */
    get component() {
      return this.options.component;
    }
    set component(component) {
      this.options.component = component;
    }
    /**
     * Get or set the intrinsic attributes of the element.
     */
    get attributes() {
      return this.options.attributes;
    }
    set attributes(attributes) {
      this.options.attributes = attributes;
    }
    /**
     * Get or set the children VNodes of this VNode.
     */
    get children() {
      return this.options.children;
    }
    set children(children) {
      this.options.children = children;
    }
    /**
     * Get or set the HTML element or text node associated with this VNode.
     */
    get element() {
      return this.options.element;
    }
    set element(element) {
      this.options.element = element;
    }
    /**
     * Get the root element this VNode is appended to
     */
    get rootElement() {
      let root = this.renderNodeParent || this.parent;
      if (root) {
        while (true) {
          if (root.element) {
            if (root.element instanceof Text) {
              this.logger.verbose({ vnode: this });
              throw Error(`A text element VNode has children.`);
            }
            return root.element;
          }
          const parent = root.renderNodeParent || root.parent;
          if (parent) {
            root = parent;
          } else {
            break;
          }
        }
        return root.options.rootElement;
      }
      return this.options.rootElement;
    }
    set rootElement(rootElement) {
      let root = this.renderNodeParent || this.parent;
      if (root) {
        while (true) {
          if (root.parent) {
            root = root.parent;
          } else {
            break;
          }
        }
        root.options.rootElement = rootElement;
        this.options.rootElement = void 0;
      } else {
        this.options.rootElement = rootElement;
      }
    }
    /**
     * Destroys the VNode
     */
    destroy() {
      if (this.destroyed) {
        return;
      }
      Object.defineProperty(this, "destroyed", {
        get: () => {
          return true;
        }
      });
      this.setAttributes();
      for (const child of this.children) {
        child.destroy();
      }
      if (this.renderNode) {
        this.renderNode.destroy();
      }
    }
    /**
     * Replaces the VNode and mounts the replacement in its place in the DOM
     * @param vnode the vnode
     */
    replace(vnode) {
      if (!this.rootElement) {
        this.logger.verbose({ vnode: this, replaceWith: vnode });
        throw new Error(`Can't replace VNode, it has no root element.`);
      }
      const parent = this.renderNodeParent ? this.renderNodeParent : this.parent;
      if (!parent) {
        this.logger.verbose({ vnode: this, replaceWith: vnode });
        throw new Error(`Can't replace VNode, it has no parent`);
      }
      vnode.id = this.id;
      vnode.parent = parent;
      const indices = this.component && this.renderNode || this.isFragment || this.element ? vnode.getRootElementIndices() : parent ? new Array(this.getElements().length).fill("").map((v, i) => i + parent.children.map((v2, i2, a) => i2 >= a.indexOf(this) ? 0 : v2.getElements().length).reduce((x, y) => x + y, 0)) : [];
      if (this.component && vnode.component) {
        this.component.component = vnode.component;
      }
      if (vnode.component) {
        vnode.isFragment = void 0;
        vnode.text = void 0;
        vnode.element = void 0;
        if (this.component) {
          if (String(this.component.constructor) === String(vnode.component.constructor)) {
            vnode.component.state = Objects.deepAssign(vnode.component.state, this.component.state);
          }
          vnode.renderNode = vnode.component.render();
        } else if (vnode.renderNode === void 0) {
          vnode.renderNode = vnode.component.render();
        }
        if (vnode.renderNode) {
          vnode.renderNode.renderNodeParent = vnode;
          vnode.renderNode.parent = vnode;
          vnode.setRootElement(this.rootElement);
          this.logger.trace(`Mounting component: `, {
            vnode,
            name: vnode.component.constructor.name,
            component: vnode.component
          });
          vnode.mount(vnode.parent, indices[0] || null);
        }
      } else if (vnode.isFragment) {
        vnode.text = void 0;
        vnode.element = void 0;
        vnode.component = void 0;
        vnode.renderNode = void 0;
        vnode.setRootElement(this.rootElement);
        this.logger.trace(`Mounting fragment: `, {
          vnode
        });
        vnode.mount(vnode.parent, indices[0] || null);
      } else if (vnode.element) {
        vnode.component = void 0;
        vnode.renderNode = void 0;
        vnode.isFragment = void 0;
        vnode.setRootElement(this.rootElement);
        this.logger.trace(`Mounting element: `, {
          element: vnode.element,
          vnode
        });
        vnode.mount(vnode.parent, indices[0] || null);
      } else {
        this.logger.verbose({ vnode: this, replaceWith: vnode });
        throw new Error(`Could not finish replacing the VNode, because its replacement is invalid.`);
      }
      const elementCount = vnode.getElements().length;
      for (let i = elementCount + indices[0] + indices.length - 1; i >= elementCount + indices[0]; i--) {
        const child = vnode.rootElement.childNodes[i];
        if (child) {
          child.remove();
        } else {
          this.logger.verbose({ child, vnode });
          throw new Error(`No child found with index: ${i}`);
        }
      }
      vnode.parent.children = vnode.parent.children.map((v) => v === this ? vnode : v);
      vnode.shouldUpdate = false;
      this.shouldUpdate = false;
      this.destroy();
    }
    /**
     * Get the elements of a vnode
     * @param elements the elements
     */
    getElements(elements = []) {
      if (this.component) {
        if (this.renderNode) {
          this.renderNode.getElements(elements);
        } else if (this.renderNode === void 0) {
          this.logger.verbose({ vnode: this, elements });
          throw new Error(`Vnode was never rendered`);
        }
      } else if (this.isFragment) {
        for (const child of this.children) {
          child.getElements(elements);
        }
      } else if (this.element) {
        elements.push(this.element);
      }
      return elements;
    }
    /**
     * Creates the elements within a root VNode
     */
    createElements(originalNode = null) {
      var _a;
      if (this.component && !this.renderNode) {
        VDOM.window.states = VDOM.window.states || [];
        const states = VDOM.window.states;
        const state = states.find((v) => v.constructor === String(this.component.constructor));
        const setState = /* @__PURE__ */ __name(() => {
          if (originalNode && originalNode.component) {
            this.component.state = __spreadValues({}, Objects.deepAssign(this.component.state, originalNode.component.state));
          }
        }, "setState");
        if (!state) {
          VDOM.window.states.push({
            constructor: String(this.component.constructor),
            state: Objects.deepAssign({}, this.component.state)
          });
          setState();
        } else if (JSON.serialize(state.state) !== JSON.serialize(this.component.state)) {
          state.state = this.component.state;
        } else {
          setState();
        }
        this.renderNode = (_a = this.component) == null ? void 0 : _a.render();
        if (this.renderNode) {
          this.renderNode.renderNodeParent = this;
          this.renderNode.createElements(originalNode);
        }
      } else if (!this.component) {
        if (this.isFragment) {
          for (let i = 0; i < this.children.length; i++) {
            this.children[i].createElements((originalNode == null ? void 0 : originalNode.children[i]) || null);
          }
        } else if (this.text) {
          this.element = this.text;
        } else if (this.tag) {
          this.element = VDOM.document.createElement(this.tag);
          this.setAttributes();
          for (let i = 0; i < this.children.length; i++) {
            this.children[i].createElements((originalNode == null ? void 0 : originalNode.children[i]) || null);
          }
        } else {
          this.logger.verbose({ vnode: this });
          throw new Error(`Unknown VNode syntax`);
        }
      }
      return null;
    }
    /**
     * Finds the node index of element within the childNodes of rootElement
     * @param rootElement the root element containing the element
     * @param element the element
     * @returns the index or -1 if not found
     */
    getNodeIndex(rootElement, element) {
      const children = rootElement.childNodes;
      for (let i = 0; i < children.length; i++) {
        const node = children[i];
        if (node === element) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Gets the element indices within any node
     * @param current the current vnode
     */
    getRootElementIndices(current = this, indices = []) {
      if (!this.rootElement) {
        this.logger.verbose({ base: this, current, indices });
        throw new Error(`Base has no root element.`);
      }
      const containingElement = this.rootElement;
      if (current.component) {
        if (current.renderNode === void 0) {
          this.logger.verbose({ base: this, current, indices });
          throw new Error(`Base has component but it hasn't been rendered yet, so it's not in the DOM.`);
        }
        if (current.renderNode) {
          return this.getRootElementIndices(current.renderNode, indices);
        }
      } else if (current.isFragment) {
        for (const child of current.children) {
          this.getRootElementIndices(child, indices);
        }
      } else if (current.element) {
        indices.push(this.getNodeIndex(containingElement, current.element));
      } else {
        this.logger.verbose({ base: this, current, indices });
        throw Error(`Invalid VNode.`);
      }
      return indices.filter((v) => v !== -1);
    }
    /**
     * Mounts the VNode into the VDOM
     * @param appendTo the vnode to append everything to, must contain a Element
     * @param type the type of processing
     */
    mount(appendTo, index = null, insertions = { count: 0 }) {
      const appendToElement = appendTo instanceof Element ? appendTo : appendTo.element || appendTo.rootElement;
      if (!appendToElement) {
        throw new Error(`No element found to mount the DOM in.`);
      }
      if (!(appendToElement instanceof HTMLElement)) {
        throw new Error(`Append to element is not of type HTMLElement.`);
      }
      if (this.component) {
        if (this.renderNode) {
          this.renderNode.mount(appendTo, index, insertions);
        } else if (this.renderNode === void 0) {
          this.logger.verbose({ vnode: this, appendTo });
          throw new Error(`VNode was never rendered`);
        }
      } else if (this.isFragment) {
        for (const child of this.children) {
          child.mount(appendTo, index, insertions);
        }
      } else if (this.element) {
        if (index !== null) {
          appendToElement.insertBefore(this.element, appendToElement.childNodes.item(index + insertions.count));
          insertions.count++;
        } else {
          appendToElement.append(this.element);
        }
        if (!(this.element instanceof Text)) {
          for (const child of this.children) {
            child.mount(this.element);
          }
        }
      } else {
        this.logger.verbose({ vnode: this, appendTo, index, insertions });
        throw new Error(`Invalid VNode object`);
      }
    }
    /**
     * Sets attributes to an element, also clears all event listeners
     * @param attributes the attributes
     * @param element the element
     */
    setAttributes() {
      if (!(this.element instanceof Element)) {
        return;
      }
      for (const name of Object.keys(this.eventListeners)) {
        const listener = this.eventListeners[name];
        this.element.removeEventListener(name, listener);
        delete this.eventListeners[name];
      }
      if (this.destroyed) {
        return;
      }
      for (const name of Object.keys(this.attributes)) {
        const value = this.attributes[name];
        const eventHandlers = [
          "onAbort",
          "onAutoComplete",
          "onAutoCompleteError",
          "onBlur",
          "onCancel",
          "onCanPlay",
          "onCanPlayThrough",
          "onChange",
          "onClick",
          "onClose",
          "onContextMenu",
          "onCueChange",
          "onDBLCLick",
          "onDrag",
          "onDragEnd",
          "onDragEnter",
          "onDragLeave",
          "onDragOver",
          "onDragStart",
          "onDrop",
          "onDurationChange",
          "onEmptied",
          "onEnded",
          "onError",
          "onFocus",
          "onInput",
          "onInvalid",
          "onKeyDown",
          "onKeyPress",
          "onKeyUp",
          "onLoad",
          "onLoadedData",
          "onLoadedMetadata",
          "onLoadStart",
          "onMouseDown",
          "onMouseEnter",
          "onMouseLeave",
          "onMouseMove",
          "onMouseOut",
          "onMouseOver",
          "onMouseUp",
          "onMouseDown",
          "onMouseEnter",
          "onMouseLeave",
          "onMouseMove",
          "onMouseOut",
          "onMouseOver",
          "onMouseUp",
          "onMouseWheel",
          "onPause",
          "onPlay",
          "onPlaying",
          "onProgress",
          "onRateChange",
          "onReset",
          "onResize",
          "onScroll",
          "onSeeked",
          "onSeeking",
          "onSelect",
          "onShow",
          "onSort",
          "onStalled",
          "onSubmit",
          "onSuspend",
          "onTimeUpdate",
          "onToggle",
          "onVolumeChange",
          "onWaiting"
        ];
        if (eventHandlers.includes(name)) {
          const eventListener = {
            name: name.replace(/^on/g, "").toLowerCase(),
            value
          };
          this.element.addEventListener(eventListener.name, eventListener.value);
          this.eventListeners[name] = eventListener.value;
          this.logger.trace(`Added event listener "${eventListener.name}" to element`, { element: this.element });
        } else if (typeof value !== "object") {
          this.element.setAttribute(name, String(value));
        } else {
          this.logger.verbose(`Unhandled attribute "${name}" on type "${this.element.tagName.toLowerCase()}"`);
        }
      }
    }
    /**
     * Gets the closest vnode containing component (if any)
     * @param vnode the vnode
     * @returns the closest vnode containing a component
     */
    getComponent(vnode = this) {
      if (!vnode) {
        return null;
      }
      if (vnode.component) {
        return vnode;
      } else {
        return this.getComponent(vnode.renderNodeParent || vnode.parent);
      }
    }
    /**
     * Copies the VNode deeply into another VNode
     */
    copy() {
      if (this.destroyed) {
        throw new Error(`Can't copy VNode, it's destroyed.`);
      }
      let copy = new _VNode(__spreadValues({}, this.options));
      copy = __spreadProps(__spreadValues(__spreadValues({}, copy), this), {
        options: __spreadValues({}, copy.options)
      });
      for (const key of Object.keys(this.options)) {
        if (key === "children") {
          const value = this[key];
          copy[key] = value ? value.map((v) => {
            v.parent = this;
            return v.copy();
          }) : [];
        } else if (key === "component") {
          copy[key] = this[key];
          const value = copy[key];
          if (value) {
            value.vnode = copy;
          }
        } else if (key === "renderNode") {
          const value = this[key];
          if (value) {
            copy[key] = value.copy();
            if (copy[key]) {
              copy[key]["renderNodeParent"] = copy;
            }
          }
        }
      }
      return copy;
    }
  };
  __name(_VNode, "VNode");
  var VNode = _VNode;

  // ../../library/framework/apps/frontend/vdom/vdom.ts
  var _VDOM = class _VDOM {
    /**
     * Mounts the VDOM and adds an instance to the VDOM.instances array
     * @param id the id of the element to mount the VDOM in. (should be unique)
     * @param root the JSX to insert at the root
     */
    constructor(id, root) {
      this.root = root;
      /**
       * The VDOM type
       */
      this.VDOM = _VDOM;
      /**
       * The VDOM id
       */
      this.id = ++_VDOM.counter;
      /**
       * Updates all nodes that should be updated by re-mounting them.
       * To prevent errors, you must use the `this.markNodesToBeUpdated` function first.
       * @param previous the previous node
       * @param current the current node
       * @param previousDOM the previous VDOM
       * @param currentDOM the current VDOM
       * @param updatedParents the parents that are already updated
       * @returns true on success
       */
      this.updateNodes = /* @__PURE__ */ __name((previous, current, previousDOM, currentDOM) => {
        if (!previous.rootElement) {
          throw new Error(`Previous has no root element`);
        }
        if (!previous.shouldUpdate || !current.shouldUpdate) {
          let success = true;
          if (previous.component && current.component) {
            if (previous.renderNode && current.renderNode) {
              for (let i = previous.renderNode.children.length - 1; i >= 0; i--) {
                if (!this.updateNodes(previous.renderNode.children[i], current.renderNode.children[i], previousDOM, currentDOM)) {
                  success = false;
                }
              }
            }
          } else if (!previous.text && !current.text) {
            if (previous.children.length == current.children.length && previous.children.length) {
              for (let i = previous.children.length - 1; i >= 0; i--) {
                if (!this.updateNodes(previous.children[i], current.children[i], previousDOM, currentDOM)) {
                  success = false;
                }
              }
            }
          }
          return success;
        }
        if (previous === previousDOM.root) {
          this.logger.trace(`Updating entire DOM`);
          currentDOM.initializeDOM();
          previousDOM.root = currentDOM.root;
          return true;
        }
        const indices = previous.getRootElementIndices();
        console.log({ indices, previous, query: previous.renderNodeParent || previous.parent ? Math.max((previous.renderNodeParent ? previous.renderNodeParent : previous.parent).children.map((v, i, a) => i >= a.indexOf(previous) ? 0 : v.getElements().length).reduce((x, y) => x + y, 0), indices[0]) : null });
        previous.replace(current);
        return true;
      }, "updateNodes");
      const main = document.querySelector(`#${id}`);
      if (!main) {
        throw new Error(`No element with id "${id}" could be found.`);
      }
      root.rootElement = main;
      this.main = main;
      this.initialize();
    }
    static get logger() {
      return new Logger2();
    }
    get logger() {
      return _VDOM.logger;
    }
    /**
     * Finds a Node by ID
     * @param id the ID
     */
    findById(id) {
      const findById = /* @__PURE__ */ __name((vnode) => {
        if (vnode.id === id && !vnode.destroyed) {
          return vnode;
        }
        if (vnode.component) {
          if (vnode.renderNode) {
            for (const child of vnode.renderNode.children) {
              const result = findById(child);
              if (result) {
                return result;
              }
            }
          } else if (vnode.renderNode === void 0) {
            this.logger.verbose({ vnode });
            throw new Error(`VNode was never rendered`);
          }
        }
        for (const child of vnode.children) {
          const result = findById(child);
          if (result) {
            return result;
          }
        }
        return null;
      }, "findById");
      return findById(this.root);
    }
    /**
     * Marks all nodes to be updated or not.
     * @param previous the previous node
     * @param current the current node
     * @returns true if everything has changed inside
     */
    markNodesToBeUpdated(previous, current, previousVDOM, currentVDOM) {
      var _a, _b;
      if (!!current.isFragment !== !!previous.isFragment || !!current.text !== !!previous.text || !!current.element !== !!previous.element || !!current.component !== !!previous.component || current.children.length !== previous.children.length || current.component && previous.component && (!!previous.renderNode !== !!current.renderNode || ((_a = previous.renderNode) == null ? void 0 : _a.children.length) !== ((_b = current.renderNode) == null ? void 0 : _b.children.length))) {
        previous.shouldUpdate = true;
        current.shouldUpdate = true;
        return true;
      } else {
        if (current.component) {
          if (current.renderNode && previous.renderNode) {
            let shouldUpdate = true;
            previous.shouldUpdate = true;
            current.shouldUpdate = true;
            for (let i = 0; i < current.renderNode.children.length; i++) {
              if (!this.markNodesToBeUpdated(previous.renderNode.children[i], current.renderNode.children[i], previousVDOM, currentVDOM)) {
                shouldUpdate = false;
                previous.shouldUpdate = false;
                current.shouldUpdate = false;
              }
            }
            return shouldUpdate;
          } else if (current.renderNode === void 0 || previous.renderNode === void 0) {
            this.logger.verbose({ current, previous });
            throw new Error(`Current or previous was never rendered`);
          } else {
            previous.shouldUpdate = true;
            current.shouldUpdate = true;
            return true;
          }
        } else if (current.isFragment) {
          this.logger.verbose("fragment");
          let shouldUpdate = true;
          previous.shouldUpdate = true;
          current.shouldUpdate = true;
          for (let i = 0; i < current.children.length; i++) {
            if (!this.markNodesToBeUpdated(previous.children[i], current.children[i], previousVDOM, currentVDOM)) {
              shouldUpdate = false;
              previous.shouldUpdate = false;
              current.shouldUpdate = false;
            }
          }
          return shouldUpdate;
        } else if (current.element) {
          this.logger.verbose("element");
          if (previous.rootElement) {
            previous.shouldUpdate = true;
            current.shouldUpdate = true;
            const values = {
              current: current.element instanceof Text ? current.element.textContent : current.element.outerHTML,
              previous: previous.element instanceof Text ? previous.element.textContent : previous.element.outerHTML
            };
            if (values.current === values.previous) {
              previous.shouldUpdate = false;
              current.shouldUpdate = false;
              return false;
            }
            let shouldUpdate = true;
            if (current.element instanceof Element) {
              for (let i = 0; i < current.children.length; i++) {
                if (!this.markNodesToBeUpdated(previous.children[i], current.children[i], previousVDOM, currentVDOM)) {
                  shouldUpdate = false;
                  previous.shouldUpdate = false;
                  current.shouldUpdate = false;
                }
              }
            }
            return shouldUpdate;
          } else {
            this.logger.verbose({ previous, current });
            throw new Error(`Previous has no root element`);
          }
        } else {
          this.logger.verbose({ invalid: current });
          throw new Error(`Invalid VNode`);
        }
      }
    }
    /**
     * Intializes the VDOM and mounts it into the main element
     * @param main the main element
     * @param root the root vnode
     */
    initialize() {
      _VDOM.window.VDOMS = _VDOM.window.VDOMS || [];
      const vdoms = _VDOM.window.VDOMS;
      const previous = vdoms.find((v) => v.main === this.main);
      const current = this;
      current.root.rootElement = current.main;
      if (previous) {
        current.root.vdom = this;
        this.logger.verbose(`Updating DOM based on Hot Reload`);
        current.root.createElements(previous.root);
        const div = _VDOM.document.createElement("div");
        current.root.mount(div);
        this.markNodesToBeUpdated(previous.root, current.root, previous, current);
        if (!this.updateNodes(previous.root, current.root, previous, current)) {
          this.logger.verbose({ previous, current });
          throw new Error(`Could not update nodes, updating DOM failed.`);
        }
        previous.root.setRootElement(previous.main);
        current.root.setRootElement(previous.main);
        current.root = previous.root;
        _VDOM.window.VDOMS = vdoms.map((v) => v.main === this.main ? this : v);
      } else {
        current.root.vdom = this;
        this.logger.verbose(`Initializing DOM`);
        this.initializeDOM();
        vdoms.push(this);
      }
    }
    /**
     * Initializes the content of the main element with the new content
     */
    initializeDOM() {
      this.main.innerHTML = "";
      this.root.createElements();
      this.root.mount(this.main);
    }
    /**
     * Creates a vnode from deepest nesting until the root of the VDOM (when a JSX element has been created)
     * @param tag the name of the tag, or a `Component` prototype
     * @param attributes the attributes of the JSX element
     * @param children the children that were created with this function before going to this parent node.
     */
    static createNode(tag, attributes, ...children) {
      SocketClient.initialize();
      const processedChildren = [];
      (children || []).forEach(/* @__PURE__ */ __name(function processChild(child) {
        if (Array.isArray(child)) {
          for (const c of child) {
            processChild(c);
          }
        } else {
          if (child instanceof VNode) {
            processedChildren.push(child);
          } else {
            const vnode2 = new VNode({
              text: child instanceof Text ? child : typeof child === "object" ? document.createElement("span") : document.createTextNode(
                typeof child === "string" ? child : String(child)
              ),
              attributes: {},
              children: []
            });
            if (vnode2.text instanceof HTMLElement) {
              vnode2.text.innerHTML = JSON.serialize(child).replace(/\r\n|\r|\n/g, "<br/>").replace(/\s/g, "&nbsp;");
            }
            processedChildren.push(vnode2);
          }
        }
      }, "processChild"));
      this.logger.verbose({
        message: "Create node called",
        tag,
        attributes,
        children,
        processedChildren
      });
      const vnode = new VNode({
        isFragment: typeof tag === "string" ? false : tag.prototype instanceof Component ? false : true,
        tag: typeof tag === "string" ? tag : void 0,
        component: typeof tag === "string" ? void 0 : tag.prototype instanceof Component ? new tag(__spreadProps(__spreadValues({}, attributes || {}), { children: processedChildren })) : void 0,
        attributes: attributes || {},
        children: processedChildren
      });
      this.logger.verbose({
        message: "new VNode",
        vnode
      });
      if (vnode.component) {
        vnode.component.vnode = vnode;
      }
      processedChildren.forEach((v) => {
        v.parent = vnode;
      });
      return vnode;
    }
  };
  __name(_VDOM, "VDOM");
  /**
   * The counter for ID's
   */
  _VDOM.counter = 0;
  /**
   * The window (either a JSDOM instance in case of Node.JS otherwise the browsers window object)
   */
  _VDOM.window = window || new (__require("jsdom")).JSDOM().window;
  /**
   * The document in the window
   */
  _VDOM.document = _VDOM.window.document;
  var VDOM = _VDOM;

  // src/app.tsx
  var _Button = class _Button extends Component {
    render() {
      return /* @__PURE__ */ VDOM.createNode("button", { class: "button", onClick: () => {
        this.props.onClick();
      } }, this.props.children);
    }
  };
  __name(_Button, "Button");
  var Button = _Button;
  var _App = class _App extends Component {
    constructor(props) {
      super(props);
      this.state = {
        clicks: 0
      };
    }
    render() {
      return /* @__PURE__ */ VDOM.createNode("div", { id: "app" }, /* @__PURE__ */ VDOM.createNode("div", { id: "app-title" }, "Hello there, you clicked ", this.state.clicks, " times!"), /* @__PURE__ */ VDOM.createNode("div", { id: "app-button" }, /* @__PURE__ */ VDOM.createNode(Button, { onClick: () => {
        this.state.clicks++;
      } }, "Click me!")));
    }
  };
  __name(_App, "App");
  var App = _App;
  new VDOM("main", /* @__PURE__ */ VDOM.createNode(App, null));
})();
